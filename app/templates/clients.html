<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Clients</title>

  <link rel="stylesheet" href="/static/app.css" />
  <link rel="icon" href="/static/favicon.ico" />
</head>
<body class="dashboard">
  <header class="app-header">
    <div class="container">
      <h1>Clients</h1>
      <div class="actions">
        <button class="btn" id="create-client">New Client</button>
      </div>
      <nav class="links">
        <a href="/" class="pill">Dashboard</a>
        <a href="/tickets" class="pill">Tickets</a>
        <a href="/hardware" class="pill">Hardware</a>
        <a href="/clients" class="pill active" aria-current="page">Clients</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <section class="table-wrap">
      <div class="table-scroll">
        <table class="table" id="clients-table">
          <thead id="clients-head"></thead>
          <tbody id="clients-body"></tbody>
        </table>
      </div>
    </section>
  </main>

  <!-- Edit modal -->
  <div id="edit-modal" class="modal-root" style="display:none;">
    <div class="modal-card modal-card--large">
      <header class="modal-head">
        <h2 id="edit-title" class="modal-title">Edit Client</h2>
        <button id="edit-close" class="btn">Close</button>
      </header>

      <form id="edit-form" class="modal-form">
        <div id="edit-fields"></div>

        <div class="form-inline">
          <input type="text" id="new-key" placeholder="new attribute key" class="mono" />
          <input type="text" id="new-val" placeholder="value" class="mono" />
          <button class="btn" id="add-attr">Add attribute</button>
        </div>
        <div class="form-actions">
          <button class="btn" type="submit">Save</button>
        </div>
      </form>
    </div>
  </div>

  <script>
const DEMOGRAPHIC_FIELDS = [
  { key: 'address_line1', label: 'Address Line 1', placeholder: '123 Main St' },
  { key: 'address_line2', label: 'Address Line 2', placeholder: 'Suite 200' },
  { key: 'city', label: 'City' },
  { key: 'state', label: 'State / Province' },
  { key: 'postal_code', label: 'Postal Code' },
  { key: 'support_hours_allowance', label: 'Support Hours Allowance', type: 'number', placeholder: 'e.g. 20' },
  { key: 'primary_contact_name', label: 'Primary Contact Name' },
  { key: 'primary_contact_phone', label: 'Primary Contact Phone', type: 'tel', linkPrefix: 'tel:', linkLabel: 'Call' },
  { key: 'primary_contact_email', label: 'Primary Contact Email', type: 'email', linkPrefix: 'mailto:', linkLabel: 'Email' },
  { key: 'office_manager_name', label: 'Office Manager Name' },
  { key: 'office_manager_phone', label: 'Office Manager Phone', type: 'tel', linkPrefix: 'tel:', linkLabel: 'Call' },
  { key: 'office_manager_email', label: 'Office Manager Email', type: 'email', linkPrefix: 'mailto:', linkLabel: 'Email' }
];
const DEMOGRAPHIC_KEYS = new Set(DEMOGRAPHIC_FIELDS.map((f) => f.key));
const ADDRESS_AUTOCOMPLETE_MIN_CHARS = 3;
const ADDRESS_AUTOCOMPLETE_DEBOUNCE = 250;
const ADDRESS_AUTOCOMPLETE_LIMIT = 8;
let ADDRESS_AUTOCOMPLETE_DISABLED = false;

function getApiToken(){ return window.localStorage.getItem('api_token') || ''; }
function setApiToken(t){ if (t) window.localStorage.setItem('api_token', t); }
function apiHeaders(json=true){
  const h = {};
  if (json) h['Content-Type'] = 'application/json';
  const t = getApiToken();
  if (t) h['X-API-Key'] = t;
  return h;
}
async function safeFetch(url, opts={}, retry=true){
  const res = await fetch(url, opts);
  if (res.status === 401 && retry){
    const t = window.prompt('Enter API token');
    if (!t) return res;
    setApiToken(t);
    const newOpts = Object.assign({}, opts);
    newOpts.headers = Object.assign({}, opts.headers || {}, {'X-API-Key': t});
    return safeFetch(url, newOpts, false);
  }
  return res;
}

function normalizeTel(value){
  return value.replace(/[^0-9+#*]/g, '');
}

function attachQuickLink(def, input){
  if (!def.linkPrefix) return null;
  const link = document.createElement('a');
  link.textContent = def.linkLabel || (def.linkPrefix === 'tel:' ? 'Call' : 'Email');
  link.style.marginLeft = '8px';
  link.className = 'mono';
  link.target = '_blank';
  link.rel = 'noopener noreferrer';
  const update = () => {
    const raw = input.value.trim();
    if (!raw){
      link.style.display = 'none';
      return;
    }
    if (def.linkPrefix === 'tel:'){
      const phone = normalizeTel(raw);
      if (!phone){
        link.style.display = 'none';
        return;
      }
      link.href = `${def.linkPrefix}${phone}`;
    } else {
      link.href = `${def.linkPrefix}${raw}`;
    }
    link.style.display = '';
    link.title = `${link.textContent} ${raw}`;
  };
  update();
  input.addEventListener('input', update);
  link.addEventListener('click', (ev) => ev.stopPropagation());
  return link;
}

function formatAddressMeta(item){
  if (!item) return '';
  const cityState = [item.city, item.state].filter(Boolean).join(', ');
  const parts = [];
  if (cityState) parts.push(cityState);
  if (item.postal_code) parts.push(item.postal_code);
  let meta = parts.join(' ').trim();
  if (item.entries && item.entries > 1){
    meta = meta ? `${meta} (${item.entries} matches)` : `${item.entries} matches`;
  }
  if (!meta) meta = 'USPS verified';
  return meta;
}

function setupAddressAutocomplete({ modal, container }){
  if (ADDRESS_AUTOCOMPLETE_DISABLED) return null;
  const line1Input = container.querySelector('input[data-attr-key="address_line1"]');
  if (!line1Input) return null;

  const line2Input = container.querySelector('input[data-attr-key="address_line2"]');
  const cityInput = container.querySelector('input[data-attr-key="city"]');
  const stateInput = container.querySelector('input[data-attr-key="state"]');
  const postalInput = container.querySelector('input[data-attr-key="postal_code"]');
  const host = line1Input.closest('label') || line1Input.parentElement;
  if (!host) return null;

  host.classList.add('address-autocomplete');
  const suggestionBox = document.createElement('div');
  suggestionBox.className = 'address-suggestions';
  const listId = `address-suggestions-${Math.random().toString(36).slice(2)}`;
  suggestionBox.id = listId;
  suggestionBox.setAttribute('role', 'listbox');
  suggestionBox.style.display = 'none';
  host.appendChild(suggestionBox);

  line1Input.setAttribute('autocomplete', 'off');
  line1Input.setAttribute('role', 'combobox');
  line1Input.setAttribute('aria-autocomplete', 'list');
  line1Input.setAttribute('aria-haspopup', 'listbox');
  line1Input.setAttribute('aria-expanded', 'false');
  line1Input.setAttribute('aria-controls', listId);

  let suggestions = [];
  let highlightedIndex = -1;
  let debounceTimer = null;
  let activeController = null;
  let destroyed = false;
  let localDisabled = false;
  let lastQuery = '';

  function cleanup(){
    if (destroyed) return;
    destroyed = true;
    if (debounceTimer) clearTimeout(debounceTimer);
    if (activeController) activeController.abort();
    line1Input.removeEventListener('input', onInput);
    line1Input.removeEventListener('focus', onFocus);
    line1Input.removeEventListener('keydown', onKeyDown);
    line1Input.removeEventListener('blur', onBlur);
    modal.removeEventListener('mousedown', onOutsidePointer);
    suggestionBox.remove();
    host.classList.remove('address-autocomplete');
    line1Input.removeAttribute('aria-controls');
    line1Input.removeAttribute('aria-expanded');
    line1Input.removeAttribute('aria-autocomplete');
    line1Input.removeAttribute('aria-haspopup');
    line1Input.removeAttribute('role');
  }

  function hideSuggestions(){
    suggestionBox.style.display = 'none';
    suggestionBox.querySelectorAll('.address-suggestion').forEach((btn) => btn.classList.remove('is-active'));
    highlightedIndex = -1;
    line1Input.setAttribute('aria-expanded', 'false');
  }

  function highlightSuggestion(index){
    const options = suggestionBox.querySelectorAll('.address-suggestion');
    options.forEach((option, idx) => option.classList.toggle('is-active', idx === index));
    highlightedIndex = index;
  }

  function renderSuggestions(){
    suggestionBox.innerHTML = '';
    if (!suggestions.length){
      hideSuggestions();
      return;
    }
    suggestions.forEach((item, index) => {
      const option = document.createElement('button');
      option.type = 'button';
      option.className = 'address-suggestion';
      option.setAttribute('role', 'option');
      option.dataset.index = String(index);
      const primary = document.createElement('div');
      primary.className = 'address-suggestion__primary';
      const streetParts = [];
      if (item.street_line) streetParts.push(item.street_line);
      if (item.secondary) streetParts.push(item.secondary);
      primary.textContent = streetParts.join(' ').trim() || item.street_line || '';
      option.appendChild(primary);
      const meta = document.createElement('div');
      meta.className = 'address-suggestion__meta';
      meta.textContent = formatAddressMeta(item);
      option.appendChild(meta);
      option.addEventListener('mouseenter', () => highlightSuggestion(index));
      option.addEventListener('mousedown', (ev) => ev.preventDefault());
      option.addEventListener('click', () => applySuggestion(item));
      suggestionBox.appendChild(option);
    });
    suggestionBox.style.display = 'block';
    line1Input.setAttribute('aria-expanded', 'true');
  }

  function applySuggestion(item){
    if (!item) return;
    if (item.street_line) line1Input.value = item.street_line;
    if (line2Input && item.secondary !== undefined && item.secondary !== null){
      line2Input.value = item.secondary || '';
    }
    if (cityInput && item.city) cityInput.value = item.city;
    if (stateInput && item.state) stateInput.value = item.state;
    if (postalInput && item.postal_code) postalInput.value = item.postal_code;
    hideSuggestions();
    line1Input.dispatchEvent(new Event('change', { bubbles: true }));
    verifySelection(item);
  }

  async function verifySelection(item){
    if (ADDRESS_AUTOCOMPLETE_DISABLED || localDisabled) return;
    const params = new URLSearchParams();
    const street = (item && item.street_line) || line1Input.value.trim();
    if (!street) return;
    params.set('street', street);
    const secondary = item.secondary || (line2Input ? line2Input.value.trim() : '');
    if (secondary) params.set('secondary', secondary);
    const cityValue = item.city || (cityInput ? cityInput.value.trim() : '');
    if (cityValue) params.set('city', cityValue);
    const stateValue = item.state || (stateInput ? stateInput.value.trim() : '');
    if (stateValue) params.set('state', stateValue);
    const zipValue = item.postal_code || (postalInput ? postalInput.value.trim() : '');
    if (zipValue) params.set('zip', zipValue);
    try {
      const res = await fetch(`/api/v1/address/verify?${params.toString()}`, {
        headers: apiHeaders(false),
      });
      if (res.status === 503){
        ADDRESS_AUTOCOMPLETE_DISABLED = true;
        localDisabled = true;
        cleanup();
        return;
      }
      if (!res.ok) return;
      const data = await res.json();
      const candidate = data.candidate || {};
      if (candidate.delivery_line_1) line1Input.value = candidate.delivery_line_1;
      if (line2Input && candidate.delivery_line_2) line2Input.value = candidate.delivery_line_2;
      if (cityInput && candidate.city) cityInput.value = candidate.city;
      if (stateInput && candidate.state) stateInput.value = candidate.state;
      if (postalInput && candidate.postal_code) postalInput.value = candidate.postal_code;
    } catch (err) {
      console.warn('Address verification failed', err);
    }
  }

  function onOutsidePointer(ev){
    if (!host.contains(ev.target)) hideSuggestions();
  }

  function onInput(){
    scheduleFetch();
  }

  function onFocus(){
    if (suggestions.length){
      renderSuggestions();
    } else if (line1Input.value.trim().length >= ADDRESS_AUTOCOMPLETE_MIN_CHARS){
      scheduleFetch();
    }
  }

  function onBlur(){
    window.setTimeout(() => {
      if (!host.contains(document.activeElement)) hideSuggestions();
    }, 150);
  }

  function onKeyDown(ev){
    if (!suggestions.length || suggestionBox.style.display === 'none') return;
    if (ev.key === 'ArrowDown'){
      ev.preventDefault();
      const nextIndex = (highlightedIndex + 1) % suggestions.length;
      highlightSuggestion(nextIndex);
    } else if (ev.key === 'ArrowUp'){
      ev.preventDefault();
      const nextIndex = highlightedIndex <= 0 ? suggestions.length - 1 : highlightedIndex - 1;
      highlightSuggestion(nextIndex);
    } else if (ev.key === 'Enter'){
      if (highlightedIndex >= 0 && highlightedIndex < suggestions.length){
        ev.preventDefault();
        applySuggestion(suggestions[highlightedIndex]);
      }
    } else if (ev.key === 'Escape'){
      hideSuggestions();
    }
  }

  function scheduleFetch(){
    if (ADDRESS_AUTOCOMPLETE_DISABLED || localDisabled) return;
    if (debounceTimer) window.clearTimeout(debounceTimer);
    debounceTimer = window.setTimeout(requestSuggestions, ADDRESS_AUTOCOMPLETE_DEBOUNCE);
  }

  async function requestSuggestions(){
    if (ADDRESS_AUTOCOMPLETE_DISABLED || localDisabled) return;
    const query = line1Input.value.trim();
    if (!query || query.length < ADDRESS_AUTOCOMPLETE_MIN_CHARS){
      suggestions = [];
      hideSuggestions();
      return;
    }
    if (query === lastQuery && suggestions.length){
      renderSuggestions();
      return;
    }
    lastQuery = query;
    if (activeController) activeController.abort();
    activeController = new AbortController();
    const params = new URLSearchParams({ query, limit: String(ADDRESS_AUTOCOMPLETE_LIMIT) });
    const cityValue = cityInput ? cityInput.value.trim() : '';
    const stateValue = stateInput ? stateInput.value.trim() : '';
    const zipValue = postalInput ? postalInput.value.trim() : '';
    if (cityValue) params.set('city', cityValue);
    if (stateValue) params.set('state', stateValue);
    if (zipValue) params.set('zip', zipValue);
    try {
      const res = await fetch(`/api/v1/address/suggest?${params.toString()}`, {
        headers: apiHeaders(false),
        signal: activeController.signal,
      });
      if (res.status === 503){
        ADDRESS_AUTOCOMPLETE_DISABLED = true;
        localDisabled = true;
        cleanup();
        return;
      }
      if (!res.ok) throw new Error('Failed to fetch address suggestions');
      const data = await res.json();
      suggestions = Array.isArray(data.suggestions) ? data.suggestions : [];
      if (!suggestions.length){
        hideSuggestions();
      } else {
        renderSuggestions();
      }
    } catch (err) {
      if (err.name === 'AbortError') return;
      console.warn('Address autocomplete failed', err);
      hideSuggestions();
    } finally {
      activeController = null;
    }
  }

  line1Input.addEventListener('input', onInput);
  line1Input.addEventListener('focus', onFocus);
  line1Input.addEventListener('keydown', onKeyDown);
  line1Input.addEventListener('blur', onBlur);
  modal.addEventListener('mousedown', onOutsidePointer);

  return cleanup;
}

function renderTable(data){
  const tableData = data.clients || {};
  const head = document.getElementById('clients-head');
  const body = document.getElementById('clients-body');
  head.innerHTML = '';
  body.innerHTML = '';

  const attributeKeys = new Set();
  Object.values(tableData).forEach((entry) => {
    Object.keys(entry || {}).forEach((k) => {
      if (k !== 'name' && !DEMOGRAPHIC_KEYS.has(k)) attributeKeys.add(k);
    });
  });
  const sortedAttributes = Array.from(attributeKeys).sort();

  const trh = document.createElement('tr');
  ['Client Key', 'Name', ...sortedAttributes, 'Actions'].forEach((label) => {
    const th = document.createElement('th');
    th.textContent = label;
    trh.appendChild(th);
  });
  head.appendChild(trh);

  Object.keys(tableData).sort((a, b) => a.localeCompare(b)).forEach((clientKey) => {
    const entry = tableData[clientKey] || {};
    const tr = document.createElement('tr');
    tr.classList.add('row');
    const tdKey = document.createElement('td');
    tdKey.textContent = clientKey;
    tdKey.className = 'mono';
    tdKey.dataset.label = 'Client Key';
    tr.appendChild(tdKey);

    const tdName = document.createElement('td');
    tdName.textContent = entry.name || '';
    tdName.style.fontWeight = '600';
    tdName.dataset.label = 'Name';
    tr.appendChild(tdName);

    sortedAttributes.forEach((attr) => {
      const td = document.createElement('td');
      const value = entry[attr];
      td.textContent = value === undefined ? '' : String(value);
      td.dataset.label = attr.replace(/_/g, ' ');
      tr.appendChild(td);
    });

    const tdAct = document.createElement('td');
    tdAct.dataset.label = 'Actions';
    tdAct.className = 'actions-cell';
    const delBtn = document.createElement('button');
    delBtn.className = 'icon-btn';
    delBtn.type = 'button';
    delBtn.title = `Delete ${entry.name || clientKey}`;
    delBtn.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path fill="currentColor" d="M9 3a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1h5v1h-2v16a2 2 0 0 1-2.1 2H8.1A2 2 0 0 1 6 20V4H4V3h5zm1 0h4v1h-4V3zM8 9h2v10H8V9zm4 0h2v10h-2V9zm4 0h2v10h-2V9z"/></svg>`;
    delBtn.addEventListener('click', async (ev) => {
      ev.stopPropagation();
      if (!confirm(`Delete client "${clientKey}"? This cannot be undone.`)) return;
      const r = await safeFetch(`/api/v1/clients/${encodeURIComponent(clientKey)}/delete`, { method: 'POST', headers: apiHeaders(false) });
      if (r.ok) loadTable(); else alert('Delete failed');
    });
    tdAct.appendChild(delBtn);
    tr.appendChild(tdAct);

    tr.addEventListener('click', () => openEditor(clientKey, entry, sortedAttributes));
    body.appendChild(tr);
  });
}

function loadTable(){
  fetch('/api/v1/clients')
    .then((r) => (r.ok ? r.json() : Promise.reject(r)))
    .then(renderTable)
    .catch(() => alert('Failed to load clients'));
}

function openEditor(clientKey, entry, attributeKeys){
  const modal = document.getElementById('edit-modal');
  const fields = document.getElementById('edit-fields');
  const nameValue = entry.name || '';
  const cleanupCallbacks = [];
  const registerCleanup = (fn) => { if (typeof fn === 'function') cleanupCallbacks.push(fn); };
  const runCleanup = () => {
    while (cleanupCallbacks.length){
      const fn = cleanupCallbacks.pop();
      try { fn(); } catch (err) { console.warn('Cleanup failed', err); }
    }
  };
  const closeModal = () => {
    runCleanup();
    modal.style.display = 'none';
  };
  document.getElementById('edit-title').textContent = `Edit Client: ${clientKey}`;
  fields.innerHTML = '';

  const nameWrap = document.createElement('label');
  nameWrap.style.display = 'block';
  nameWrap.style.marginBottom = '10px';
  nameWrap.textContent = 'Display Name ';
  const nameInput = document.createElement('input');
  nameInput.id = 'edit-name';
  nameInput.value = nameValue;
  nameInput.required = true;
  nameInput.className = 'mono';
  nameWrap.appendChild(nameInput);
  fields.appendChild(nameWrap);

  const demoHeading = document.createElement('h3');
  demoHeading.textContent = 'Demographics';
  demoHeading.style.margin = '12px 0 4px';
  demoHeading.style.fontSize = '1rem';
  demoHeading.style.fontWeight = '600';
  fields.appendChild(demoHeading);

  const demographicsContainer = document.createElement('div');
  demographicsContainer.id = 'demographics-container';
  demographicsContainer.style.display = 'flex';
  demographicsContainer.style.flexDirection = 'column';
  demographicsContainer.style.gap = '8px';
  fields.appendChild(demographicsContainer);

  function addDemographicRow(def){
    const wrap = document.createElement('label');
    wrap.style.display = 'block';
    wrap.style.marginBottom = '6px';
    wrap.textContent = `${def.label} `;
    const input = document.createElement('input');
    input.className = 'mono';
    input.type = def.type || 'text';
    if (def.placeholder) input.placeholder = def.placeholder;
    input.value = entry[def.key] != null ? String(entry[def.key]) : '';
    input.dataset.attrKey = def.key;
    input.dataset.demographic = 'true';
    wrap.appendChild(input);
    const quickLink = attachQuickLink(def, input);
    if (quickLink) wrap.appendChild(quickLink);
    demographicsContainer.appendChild(wrap);
  }

  DEMOGRAPHIC_FIELDS.forEach(addDemographicRow);

  const autocompleteCleanup = setupAddressAutocomplete({ modal, container: demographicsContainer });
  if (autocompleteCleanup) registerCleanup(autocompleteCleanup);

  const attrHeading = document.createElement('h3');
  attrHeading.textContent = 'Custom Attributes';
  attrHeading.style.margin = '16px 0 4px';
  attrHeading.style.fontSize = '1rem';
  attrHeading.style.fontWeight = '600';
  fields.appendChild(attrHeading);

  const attrContainer = document.createElement('div');
  attrContainer.id = 'attribute-container';
  attrContainer.style.display = 'flex';
  attrContainer.style.flexDirection = 'column';
  attrContainer.style.gap = '8px';
  fields.appendChild(attrContainer);

  const seenAttrKeys = new Set();

  function addAttrRow(key, value){
    if (!key || key === 'name') return;
    const normalizedKey = key;
    if (DEMOGRAPHIC_KEYS.has(normalizedKey)){
      const target = demographicsContainer.querySelector(`input[data-attr-key="${normalizedKey}"]`);
      if (target){
        target.value = value == null ? '' : String(value);
        target.dispatchEvent(new Event('input'));
      }
      return;
    }
    if (seenAttrKeys.has(normalizedKey)){
      const existing = attrContainer.querySelector(`input[data-attr-key="${normalizedKey}"]`);
      if (existing){
        existing.value = value == null ? '' : String(value);
      }
      return;
    }
    seenAttrKeys.add(normalizedKey);
    const wrap = document.createElement('label');
    wrap.style.display = 'block';
    wrap.style.marginBottom = '6px';
    wrap.textContent = normalizedKey.replace(/_/g, ' ') + ' ';
    const input = document.createElement('input');
    input.value = value == null ? '' : String(value);
    input.dataset.attrKey = normalizedKey;
    input.className = 'mono';
    wrap.appendChild(input);
    attrContainer.appendChild(wrap);
  }

  if (Array.isArray(attributeKeys) && attributeKeys.length){
    attributeKeys.forEach((key) => addAttrRow(key, entry[key]));
  }
  Object.keys(entry || {}).forEach((key) => {
    if (key === 'name') return;
    addAttrRow(key, entry[key]);
  });

  document.getElementById('edit-close').onclick = closeModal;
  modal.style.display = 'block';

  document.getElementById('edit-form').onsubmit = async (ev) => {
    ev.preventDefault();
    const name = nameInput.value.trim();
    if (!name){
      alert('Display name is required');
      return;
    }
    const payload = { name, attributes: {} };
    demographicsContainer.querySelectorAll('input[data-attr-key]').forEach((inp) => {
      const key = inp.dataset.attrKey;
      if (!key) return;
      payload.attributes[key] = inp.value.trim();
    });
    attrContainer.querySelectorAll('input[data-attr-key]').forEach((inp) => {
      const key = inp.dataset.attrKey;
      if (!key) return;
      payload.attributes[key] = inp.value.trim();
    });
    const r = await safeFetch(`/api/v1/clients/${encodeURIComponent(clientKey)}`, {
      method: 'PATCH',
      headers: apiHeaders(true),
      body: JSON.stringify(payload)
    });
    if (r.ok){
      closeModal();
      loadTable();
    } else {
      alert('Save failed');
    }
  };

  document.getElementById('add-attr').onclick = (ev) => {
    ev.preventDefault();
    const newKeyInput = document.getElementById('new-key');
    const newValInput = document.getElementById('new-val');
    const key = (newKeyInput.value || '').trim();
    if (!key) return;
    const value = newValInput.value || '';
    if (DEMOGRAPHIC_KEYS.has(key)){
      const target = demographicsContainer.querySelector(`input[data-attr-key="${key}"]`);
      if (target){
        target.value = value;
        target.dispatchEvent(new Event('input'));
        target.focus();
      }
    } else {
      addAttrRow(key, value);
      const target = attrContainer.querySelector(`input[data-attr-key="${key}"]`);
      if (target) target.focus();
    }
    newKeyInput.value = '';
    newValInput.value = '';
  };
}

document.getElementById('create-client').addEventListener('click', async () => {
  const clientKey = prompt('New client key (e.g., nds):');
  if (!clientKey) return;
  const name = prompt('Display name for this client:');
  if (!name) return;
  const r = await safeFetch('/api/v1/clients', {
    method: 'POST',
    headers: apiHeaders(true),
    body: JSON.stringify({ client_key: clientKey.trim(), name: name.trim(), attributes: {} })
  });
  if (r.ok) loadTable(); else alert('Create failed');
});

loadTable();
</script>

