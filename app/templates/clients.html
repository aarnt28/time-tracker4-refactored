<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Clients</title>

  <link rel="stylesheet" href="/static/app.css" />
  <link rel="icon" href="/static/favicon.ico" />
</head>
<body class="dashboard">
  <header class="app-header">
    <div class="container">
      <div class="branding">
        <img
          src="/static/img/vip-full-hd-transparant-cropped-halfsize.png"
          srcset="/static/img/vip-full-hd-transparant-cropped-halfsize.png 1x, /static/img/vip-full-hd-transparant-384x150.png 2x"
          alt="VIP Clouds logo"
          class="branding__logo"
        />
        <div class="branding__meta">
          <span class="branding__kicker">VIP Clouds</span>
          <h1 class="logo"><a href="/">Time Tracker</a></h1>
        </div>
      </div>
      <h2 class="page-title">Clients</h2>
      <div class="actions">
        <button class="btn" id="customize-columns">Customize Columns</button>
        <button class="btn" id="manage-attributes">Manage Custom Attributes</button>
        <button class="btn" id="create-client">New Client</button>
        <button class="btn" id="open-route-planner">Route Planner</button>
      </div>
      <nav class="links">
        <a href="/" class="pill">Dashboard</a>
        <a href="/tickets" class="pill">Tickets</a>
        <a href="/hardware" class="pill">Hardware</a>
        <a href="/inventory" class="pill">Inventory</a>
        <a href="/clients" class="pill active" aria-current="page">Clients</a>
        <a href="/reports" class="pill">Reports</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <section class="table-wrap">
      <div class="table-scroll">
        <table class="table" id="clients-table">
          <thead id="clients-head"></thead>
          <tbody id="clients-body"></tbody>
        </table>
      </div>
    </section>
    <section id="clients-map-section" class="clients-map" aria-live="polite">
      <div class="clients-map__header">
        <h2 class="clients-map__title">Client Locations</h2>
        <p id="clients-map-status" class="clients-map__status">
          Add client addresses to see them on the map.
        </p>
      </div>
      <div id="clients-map-canvas" class="clients-map__canvas" role="presentation" style="display:none;"></div>
    </section>
    <section id="route-planner" class="route-planner" aria-live="polite">
      <header class="route-planner__header">
        <h2 class="route-planner__title">Route Planner</h2>
        <p class="route-planner__subtitle">
          Plan visits starting from <span id="route-origin" class="route-planner__origin"></span>.
        </p>
      </header>
      <div class="route-planner__layout">
        <div class="route-planner__controls">
          <label class="route-planner__field" for="route-client-select">
            <span class="route-planner__label">Select stops to visit</span>
            <select id="route-client-select" class="route-planner__select" multiple size="10" aria-describedby="route-planner-status"></select>
          </label>
          <div class="route-planner__buttons">
            <button class="btn" type="button" id="route-add">Add to Route</button>
            <button class="btn btn-ghost" type="button" id="route-clear">Clear Route</button>
          </div>
          <p id="route-planner-status" class="route-planner__status">Loading stops…</p>
        </div>
        <div class="route-planner__stops">
          <div class="route-planner__stops-header">
            <h3 class="route-planner__stops-title">Stops</h3>
            <p class="route-planner__stops-note">Reorder stops to adjust the visit sequence.</p>
          </div>
          <div id="route-selection" class="route-planner__list" role="group" aria-label="Selected route stops"></div>
          <div class="route-planner__actions">
            <button class="btn" type="button" id="route-build">Build Route</button>
            <button class="btn btn-ghost" type="button" id="route-optimize">Optimize Order</button>
          </div>
          <div id="route-summary" class="route-planner__summary" aria-live="polite"></div>
        </div>
      </div>
      <div id="route-map" class="route-planner__map" role="presentation" style="display:none;"></div>
    </section>
  </main>

  <!-- Edit modal -->
  <div id="edit-modal" class="modal-root" style="display:none;">
    <div class="modal-card modal-card--large">
      <header class="modal-head">
        <h2 id="edit-title" class="modal-title">Edit Client</h2>
        <button id="edit-close" class="btn">Close</button>
      </header>

      <form id="edit-form" class="modal-form">
        <div id="edit-fields"></div>
        <div class="form-actions">
          <button class="btn" type="submit">Save</button>
        </div>
      </form>
    </div>
  </div>

  <div id="attributes-modal" class="modal-root" style="display:none;">
    <div class="modal-card">
      <header class="modal-head">
        <h2 class="modal-title">Manage Custom Attributes</h2>
        <button id="attributes-close" class="btn">Close</button>
      </header>
      <div class="modal-form">
        <p class="modal-note">Custom attributes appear for every client. Removing one will delete its values for all clients.</p>
        <div id="attributes-list" class="attribute-list"></div>
        <form id="attribute-add-form" class="form-inline" style="margin-top:16px;">
          <input type="text" id="attribute-new-key" placeholder="new attribute key" class="mono" />
          <button class="btn" type="submit">Add attribute</button>
        </form>
      </div>
    </div>
  </div>

  <div id="columns-modal" class="modal-root" style="display:none;">
    <div class="modal-card modal-card--medium">
      <header class="modal-head">
        <h2 class="modal-title">Customize Columns</h2>
        <button id="columns-close" class="btn">Close</button>
      </header>
      <form id="columns-form" class="modal-form">
        <p class="modal-note">Choose which columns should appear in the table. Newly added attributes are included automatically.</p>
        <div id="columns-options" class="column-option-list"></div>
        <div class="form-actions">
          <button class="btn" type="submit">Apply</button>
        </div>
      </form>
    </div>
  </div>

  <script>
const DEMOGRAPHIC_FIELDS = [
  { key: 'address_line1', label: 'Address Line 1', placeholder: '123 Main St' },
  { key: 'address_line2', label: 'Address Line 2', placeholder: 'Suite 200' },
  { key: 'city', label: 'City' },
  { key: 'state', label: 'State / Province' },
  { key: 'postal_code', label: 'Postal Code' },
  { key: 'support_hours_allowance', label: 'Support Hours Allowance', type: 'number', placeholder: 'e.g. 20' },
  { key: 'primary_contact_name', label: 'Primary Contact Name' },
  { key: 'primary_contact_phone', label: 'Primary Contact Phone', type: 'tel', linkPrefix: 'tel:', linkLabel: 'Call' },
  { key: 'primary_contact_email', label: 'Primary Contact Email', type: 'email', linkPrefix: 'mailto:', linkLabel: 'Email' },
  { key: 'office_manager_name', label: 'Office Manager Name' },
  { key: 'office_manager_phone', label: 'Office Manager Phone', type: 'tel', linkPrefix: 'tel:', linkLabel: 'Call' },
  { key: 'office_manager_email', label: 'Office Manager Email', type: 'email', linkPrefix: 'mailto:', linkLabel: 'Email' }
];
const DEMOGRAPHIC_KEYS = new Set(DEMOGRAPHIC_FIELDS.map((f) => f.key));
const ADDRESS_AUTOCOMPLETE_MIN_CHARS = 3;
const ADDRESS_AUTOCOMPLETE_DEBOUNCE = 250;
const ADDRESS_AUTOCOMPLETE_LIMIT = 20;
let ADDRESS_AUTOCOMPLETE_DISABLED = false;
let currentAttributeKeys = [];
const GOOGLE_MAPS_API_KEY = {{ (google_maps_api_key or '')|tojson }};
let googleMapsLoaderPromise = null;
const BASE_TABLE_COLUMNS = [
  { key: '__client_key__', label: 'Client Key', defaultVisible: true },
  { key: 'name', label: 'Name', defaultVisible: true }
];
const DEMOGRAPHIC_TABLE_COLUMNS = DEMOGRAPHIC_FIELDS.map((field) => ({
  key: field.key,
  label: field.label,
  defaultVisible: false
}));
const COLUMN_STORAGE_KEY = 'clients_table_columns_v1';
let availableTableColumns = BASE_TABLE_COLUMNS.slice();
let visibleColumnKeys = new Set(BASE_TABLE_COLUMNS.filter((col) => col.defaultVisible !== false).map((col) => col.key));
let latestTablePayload = null;
const clientsMapSection = document.getElementById('clients-map-section');
const clientsMapStatus = document.getElementById('clients-map-status');
const clientsMapCanvas = document.getElementById('clients-map-canvas');
let clientsMapInstance = null;
let clientsMapMarkers = [];
let clientsMapInfoWindow = null;
let clientsMapGeocoder = null;
let clientsMapRequestId = 0;
const clientsMapGeocodeCache = new Map();
const ROUTE_PLANNER_ORIGIN = '1409 Parkview St, Longview, TX 75601';
const ROUTE_PLANNER_ORIGIN_COORDS = { lat: 32.5086, lng: -94.7424 };
const ROUTE_PLANNER_STATIC_STOPS = [
  { clientKey: '__vendor_buccees__', name: 'Buc-ee\u2019s', address: '506 I-20, Terrell, TX 75160' },
  { clientKey: '__vendor_microcenter__', name: 'Microcenter', address: '13929 N Central Expy, Dallas, TX 75243' }
];
const routePlannerSection = document.getElementById('route-planner');
const routeOriginDisplay = document.getElementById('route-origin');
const routeClientSelect = document.getElementById('route-client-select');
const routeAddButton = document.getElementById('route-add');
const routeClearButton = document.getElementById('route-clear');
const routeSelectionList = document.getElementById('route-selection');
const routeBuildButton = document.getElementById('route-build');
const routeOptimizeButton = document.getElementById('route-optimize');
const routeSummary = document.getElementById('route-summary');
const routeStatus = document.getElementById('route-planner-status');
const routeMapCanvas = document.getElementById('route-map');
const openRoutePlannerBtn = document.getElementById('open-route-planner');
const routeSelectableClients = new Map();
let routeSelection = [];
let routeMapInstance = null;
let routeDirectionsService = null;
let routeDirectionsRenderer = null;
let routeRequestId = 0;
let routeHighlightTimer = null;

if (routeBuildButton) routeBuildButton.disabled = true;
if (routeOptimizeButton) routeOptimizeButton.disabled = true;
if (routeClearButton) routeClearButton.disabled = true;

if (routeOriginDisplay){
  routeOriginDisplay.textContent = ROUTE_PLANNER_ORIGIN;
}

if (openRoutePlannerBtn && routePlannerSection){
  openRoutePlannerBtn.addEventListener('click', () => {
    if (routeHighlightTimer){
      clearTimeout(routeHighlightTimer);
      routeHighlightTimer = null;
    }
    routePlannerSection.classList.add('route-planner--highlight');
    routePlannerSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
    routeHighlightTimer = setTimeout(() => {
      routePlannerSection.classList.remove('route-planner--highlight');
      routeHighlightTimer = null;
    }, 1200);
  });
}

function getApiToken(){ return window.localStorage.getItem('api_token') || ''; }
function setApiToken(t){ if (t) window.localStorage.setItem('api_token', t); }
function apiHeaders(json=true){
  const h = {};
  if (json) h['Content-Type'] = 'application/json';
  const t = getApiToken();
  if (t) h['X-API-Key'] = t;
  return h;
}
async function safeFetch(url, opts={}, retry=true){
  const res = await fetch(url, opts);
  if (res.status === 401 && retry){
    const t = window.prompt('Enter API token');
    if (!t) return res;
    setApiToken(t);
    const newOpts = Object.assign({}, opts);
    newOpts.headers = Object.assign({}, opts.headers || {}, {'X-API-Key': t});
    return safeFetch(url, newOpts, false);
  }
  return res;
}

function formatAttributeLabel(key){
  return key.replace(/_/g, ' ').replace(/\b\w/g, (c) => c.toUpperCase());
}

function loadColumnPreferences(){
  try {
    const raw = window.localStorage.getItem(COLUMN_STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') return null;
    return parsed;
  } catch (err) {
    console.warn('Failed to load column preferences', err);
    return null;
  }
}

function saveColumnPreferences(selectedKeys, availableKeys){
  try {
    const payload = {
      selected: Array.isArray(selectedKeys) ? selectedKeys.slice() : [],
      known: Array.isArray(availableKeys) ? availableKeys.slice() : []
    };
    window.localStorage.setItem(COLUMN_STORAGE_KEY, JSON.stringify(payload));
  } catch (err) {
    console.warn('Failed to save column preferences', err);
  }
}

function applyColumnPreferences(availableOptions){
  const availableKeys = availableOptions.map((col) => col.key);
  const defaultVisibleKeys = availableOptions
    .filter((col) => col.defaultVisible !== false)
    .map((col) => col.key);
  let selectedKeys = defaultVisibleKeys.slice();
  const prefs = loadColumnPreferences();
  if (prefs){
    const storedSelected = Array.isArray(prefs.selected) ? prefs.selected.filter((key) => availableKeys.includes(key)) : [];
    const knownKeys = Array.isArray(prefs.known) ? prefs.known : [];
    selectedKeys = storedSelected.length ? storedSelected.slice() : defaultVisibleKeys.slice();
    const newKeys = availableKeys.filter((key) => !knownKeys.includes(key));
    newKeys.forEach((key) => {
      const def = availableOptions.find((col) => col.key === key);
      if (def && def.defaultVisible !== false && !selectedKeys.includes(key)){
        selectedKeys.push(key);
      }
    });
    if (!selectedKeys.length){
      selectedKeys = defaultVisibleKeys.slice();
    }
  }
  visibleColumnKeys = new Set(selectedKeys);
  saveColumnPreferences(Array.from(visibleColumnKeys), availableKeys);
  return availableOptions.filter((col) => visibleColumnKeys.has(col.key));
}

function formatCellValue(value){
  if (value === undefined || value === null) return '';
  if (Array.isArray(value)) return value.join(', ');
  if (typeof value === 'object'){
    try {
      return JSON.stringify(value);
    } catch (err) {
      return String(value);
    }
  }
  return String(value);
}

function escapeHtml(value){
  const str = value == null ? '' : String(value);
  const replacements = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };
  return str.replace(/[&<>"']/g, (char) => replacements[char] || char);
}

function normalizeTel(value){
  return value.replace(/[^0-9+#*]/g, '');
}

function loadGoogleMaps(){
  if (!GOOGLE_MAPS_API_KEY){
    return Promise.reject(new Error('Google Maps API key is not configured'));
  }
  if (window.google && window.google.maps){
    return Promise.resolve(window.google.maps);
  }
  if (googleMapsLoaderPromise){
    return googleMapsLoaderPromise;
  }
  googleMapsLoaderPromise = new Promise((resolve, reject) => {
    const existing = document.querySelector('script[data-google-maps-loader="true"]');
    if (existing){
      existing.addEventListener('load', () => {
        if (window.google && window.google.maps){
          resolve(window.google.maps);
        } else {
          reject(new Error('Google Maps failed to initialize'));
        }
      });
      existing.addEventListener('error', () => reject(new Error('Google Maps failed to load')));
      return;
    }
    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(GOOGLE_MAPS_API_KEY)}`;
    script.async = true;
    script.defer = true;
    script.dataset.googleMapsLoader = 'true';
    script.onload = () => {
      if (window.google && window.google.maps){
        resolve(window.google.maps);
      } else {
        reject(new Error('Google Maps failed to initialize'));
      }
    };
    script.onerror = () => reject(new Error('Google Maps failed to load'));
    document.head.appendChild(script);
  });
  return googleMapsLoaderPromise;
}

function hasClientMapAddress(entry){
  if (!entry) return false;
  const parts = [
    entry.address_line1,
    entry.city,
    entry.state,
    entry.postal_code
  ].map((part) => (part == null ? '' : String(part).trim())).filter(Boolean);
  return parts.length >= 2;
}

function buildClientMapAddress(entry){
  if (!entry) return '';
  const parts = [];
  if (entry.address_line1) parts.push(entry.address_line1);
  if (entry.address_line2) parts.push(entry.address_line2);
  const cityState = [entry.city, entry.state].filter((value) => !!value).join(', ');
  if (cityState) parts.push(cityState);
  if (entry.postal_code) parts.push(entry.postal_code);
  return parts.join(', ');
}

function clearClientsMapMarkers(){
  if (!clientsMapMarkers.length) return;
  clientsMapMarkers.forEach((marker) => {
    try {
      marker.setMap(null);
    } catch (err) {
      console.warn('Failed to clear client map marker', err);
    }
  });
  clientsMapMarkers = [];
  if (clientsMapInfoWindow){
    clientsMapInfoWindow.close();
  }
}

async function refreshClientsMap(tableData){
  if (!clientsMapSection || !clientsMapStatus || !clientsMapCanvas){
    return;
  }
  if (!GOOGLE_MAPS_API_KEY){
    clientsMapSection.classList.add('clients-map--disabled');
    clientsMapStatus.textContent = 'Set the GOOGLE_MAPS_API_KEY environment variable to enable the client locations map.';
    clientsMapCanvas.style.display = 'none';
    clearClientsMapMarkers();
    return;
  }
  clientsMapSection.classList.remove('clients-map--disabled');
  const entries = Object.entries(tableData || {}).map(([clientKey, entry]) => ({
    clientKey,
    entry: entry || {}
  }));
  const mappable = entries.filter(({ entry }) => hasClientMapAddress(entry));
  if (!mappable.length){
    clearClientsMapMarkers();
    clientsMapCanvas.style.display = 'none';
    clientsMapStatus.textContent = 'No client addresses available yet.';
    return;
  }
  const requestId = ++clientsMapRequestId;
  clientsMapStatus.textContent = 'Loading client locations…';
  try {
    const maps = await loadGoogleMaps();
    if (clientsMapRequestId !== requestId) return;
    if (!clientsMapGeocoder){
      clientsMapGeocoder = new maps.Geocoder();
    }
    const located = [];
    const unmatched = [];
    for (const item of mappable){
      const address = buildClientMapAddress(item.entry);
      if (!address){
        unmatched.push(item);
        continue;
      }
      let cached = clientsMapGeocodeCache.get(address);
      if (cached === undefined){
        cached = await new Promise((resolve) => {
          clientsMapGeocoder.geocode({ address }, (results, status) => {
            if (status === 'OK' && results && results.length){
              const result = results[0];
              resolve({
                location: result.geometry && result.geometry.location,
                formattedAddress: result.formatted_address || address
              });
            } else {
              resolve(null);
            }
          });
        });
        clientsMapGeocodeCache.set(address, cached);
      }
      if (clientsMapRequestId !== requestId) return;
      if (cached && cached.location){
        located.push({
          clientKey: item.clientKey,
          name: item.entry.name || item.clientKey,
          address: cached.formattedAddress || address,
          location: cached.location
        });
      } else {
        unmatched.push(item);
      }
    }
    if (clientsMapRequestId !== requestId) return;
    if (!located.length){
      clearClientsMapMarkers();
      clientsMapCanvas.style.display = 'none';
      clientsMapStatus.textContent = 'Google Maps could not locate any client addresses yet.';
      return;
    }
    clientsMapCanvas.style.display = 'block';
    if (!clientsMapInstance){
      clientsMapInstance = new maps.Map(clientsMapCanvas, {
        center: located[0].location,
        zoom: located.length === 1 ? 14 : 10,
        mapTypeControl: false,
        streetViewControl: false,
        fullscreenControl: false
      });
    } else {
      clientsMapInstance.setCenter(located[0].location);
    }
    clearClientsMapMarkers();
    if (!clientsMapInfoWindow){
      clientsMapInfoWindow = new maps.InfoWindow();
    } else {
      clientsMapInfoWindow.close();
    }
    const bounds = new maps.LatLngBounds();
    located.forEach((item) => {
      const marker = new maps.Marker({
        map: clientsMapInstance,
        position: item.location,
        title: item.name
      });
      marker.addListener('click', () => {
        clientsMapInfoWindow.setContent(
          `<div class="clients-map__infowindow"><strong>${escapeHtml(item.name)}</strong><div>${escapeHtml(item.address)}</div></div>`
        );
        clientsMapInfoWindow.open({ anchor: marker, map: clientsMapInstance, shouldFocus: false });
      });
      clientsMapMarkers.push(marker);
      if (item.location) bounds.extend(item.location);
    });
    if (located.length > 1){
      clientsMapInstance.fitBounds(bounds);
    } else {
      clientsMapInstance.setZoom(14);
    }
    let statusMessage = `Showing ${located.length} client location${located.length === 1 ? '' : 's'}.`;
    if (unmatched.length){
      statusMessage += ` ${unmatched.length} address${unmatched.length === 1 ? '' : 'es'} could not be located.`;
    }
    clientsMapStatus.textContent = statusMessage;
  } catch (err) {
    if (clientsMapRequestId !== requestId) return;
    console.warn('Failed to refresh client map', err);
    clearClientsMapMarkers();
    clientsMapCanvas.style.display = 'none';
    clientsMapStatus.textContent = 'Google Maps is unavailable. Check your API key and connectivity.';
  }
}

function attachQuickLink(def, input){
  if (!def.linkPrefix) return null;
  const link = document.createElement('a');
  link.textContent = def.linkLabel || (def.linkPrefix === 'tel:' ? 'Call' : 'Email');
  link.style.marginLeft = '8px';
  link.className = 'mono';
  link.target = '_blank';
  link.rel = 'noopener noreferrer';
  const update = () => {
    const raw = input.value.trim();
    if (!raw){
      link.style.display = 'none';
      return;
    }
    if (def.linkPrefix === 'tel:'){
      const phone = normalizeTel(raw);
      if (!phone){
        link.style.display = 'none';
        return;
      }
      link.href = `${def.linkPrefix}${phone}`;
    } else {
      link.href = `${def.linkPrefix}${raw}`;
    }
    link.style.display = '';
    link.title = `${link.textContent} ${raw}`;
  };
  update();
  input.addEventListener('input', update);
  link.addEventListener('click', (ev) => ev.stopPropagation());
  return link;
}

function formatAddressMeta(item){
  if (!item) return '';
  const cityState = [item.city, item.state].filter(Boolean).join(', ');
  const parts = [];
  if (cityState) parts.push(cityState);
  if (item.postal_code) parts.push(item.postal_code);
  if (item.country) parts.push(item.country);
  if (!parts.length && item.formatted) parts.push(item.formatted);
  if (!parts.length) parts.push('Google Maps');
  return parts.join(' · ');
}

function setupAddressAutocomplete({ modal, container }){
  if (ADDRESS_AUTOCOMPLETE_DISABLED) return null;
  const line1Input = container.querySelector('input[data-attr-key="address_line1"]');
  if (!line1Input) return null;

  const line2Input = container.querySelector('input[data-attr-key="address_line2"]');
  const cityInput = container.querySelector('input[data-attr-key="city"]');
  const stateInput = container.querySelector('input[data-attr-key="state"]');
  const postalInput = container.querySelector('input[data-attr-key="postal_code"]');
  const host = line1Input.closest('label') || line1Input.parentElement;
  if (!host) return null;

  host.classList.add('address-autocomplete');
  const suggestionBox = document.createElement('div');
  suggestionBox.className = 'address-suggestions';
  const listId = `address-suggestions-${Math.random().toString(36).slice(2)}`;
  suggestionBox.id = listId;
  suggestionBox.setAttribute('role', 'listbox');
  suggestionBox.style.display = 'none';
  host.appendChild(suggestionBox);

  line1Input.setAttribute('autocomplete', 'off');
  line1Input.setAttribute('role', 'combobox');
  line1Input.setAttribute('aria-autocomplete', 'list');
  line1Input.setAttribute('aria-haspopup', 'listbox');
  line1Input.setAttribute('aria-expanded', 'false');
  line1Input.setAttribute('aria-controls', listId);

  let suggestions = [];
  let highlightedIndex = -1;
  let debounceTimer = null;
  let activeController = null;
  let destroyed = false;
  let localDisabled = false;
  let lastQuery = '';

  function setInputValue(input, value){
    if (!input) return false;
    const normalized = value == null ? '' : String(value);
    if (input.value === normalized) return false;
    input.value = normalized;
    return true;
  }

  function emitInputEvent(input){
    if (!input) return;
    input.dispatchEvent(new Event('input', { bubbles: true }));
  }

  function cleanup(){
    if (destroyed) return;
    destroyed = true;
    if (debounceTimer) clearTimeout(debounceTimer);
    if (activeController) activeController.abort();
    line1Input.removeEventListener('input', onInput);
    line1Input.removeEventListener('focus', onFocus);
    line1Input.removeEventListener('keydown', onKeyDown);
    line1Input.removeEventListener('blur', onBlur);
    modal.removeEventListener('mousedown', onOutsidePointer);
    suggestionBox.remove();
    host.classList.remove('address-autocomplete');
    line1Input.removeAttribute('aria-controls');
    line1Input.removeAttribute('aria-expanded');
    line1Input.removeAttribute('aria-autocomplete');
    line1Input.removeAttribute('aria-haspopup');
    line1Input.removeAttribute('role');
  }

  function hideSuggestions(){
    suggestionBox.style.display = 'none';
    suggestionBox.querySelectorAll('.address-suggestion').forEach((btn) => btn.classList.remove('is-active'));
    highlightedIndex = -1;
    line1Input.setAttribute('aria-expanded', 'false');
  }

  function highlightSuggestion(index){
    const options = suggestionBox.querySelectorAll('.address-suggestion');
    options.forEach((option, idx) => option.classList.toggle('is-active', idx === index));
    highlightedIndex = index;
  }

  function renderSuggestions(){
    suggestionBox.innerHTML = '';
    if (!suggestions.length){
      hideSuggestions();
      return;
    }
    suggestions.forEach((item, index) => {
      const option = document.createElement('button');
      option.type = 'button';
      option.className = 'address-suggestion';
      option.setAttribute('role', 'option');
      option.dataset.index = String(index);
      const primary = document.createElement('div');
      primary.className = 'address-suggestion__primary';
      const streetParts = [];
      if (item.street_line) streetParts.push(item.street_line);
      if (item.secondary) streetParts.push(item.secondary);
      primary.textContent = streetParts.join(' ').trim() || item.street_line || '';
      option.appendChild(primary);
      const meta = document.createElement('div');
      meta.className = 'address-suggestion__meta';
      meta.textContent = formatAddressMeta(item);
      option.appendChild(meta);
      option.addEventListener('mouseenter', () => highlightSuggestion(index));
      option.addEventListener('mousedown', (ev) => ev.preventDefault());
      option.addEventListener('click', () => applySuggestion(item));
      suggestionBox.appendChild(option);
    });
    suggestionBox.style.display = 'block';
    line1Input.setAttribute('aria-expanded', 'true');
  }

  function applySuggestion(item){
    if (!item) return;
    const changedInputs = new Set();
    if (item.street_line && setInputValue(line1Input, item.street_line)){
      changedInputs.add(line1Input);
    }
    if (line2Input && item.secondary !== undefined && item.secondary !== null){
      if (setInputValue(line2Input, item.secondary || '')){
        changedInputs.add(line2Input);
      }
    }
    if (cityInput && item.city && setInputValue(cityInput, item.city)){
      changedInputs.add(cityInput);
    }
    if (stateInput && item.state && setInputValue(stateInput, item.state)){
      changedInputs.add(stateInput);
    }
    if (postalInput && item.postal_code && setInputValue(postalInput, item.postal_code)){
      changedInputs.add(postalInput);
    }
    hideSuggestions();
    const seen = new Set();
    changedInputs.forEach((input) => {
      if (input && !seen.has(input)){
        emitInputEvent(input);
        seen.add(input);
      }
    });
    if (!seen.has(line1Input)) emitInputEvent(line1Input);
    verifySelection(item);
  }

  async function verifySelection(item){
    if (ADDRESS_AUTOCOMPLETE_DISABLED || localDisabled) return;
    const params = new URLSearchParams();
    const street = (item && item.street_line) || line1Input.value.trim();
    if (!street) return;
    params.set('street', street);
    const secondary = item.secondary || (line2Input ? line2Input.value.trim() : '');
    if (secondary) params.set('secondary', secondary);
    const cityValue = item.city || (cityInput ? cityInput.value.trim() : '');
    if (cityValue) params.set('city', cityValue);
    const stateValue = item.state || (stateInput ? stateInput.value.trim() : '');
    if (stateValue) params.set('state', stateValue);
    const zipValue = item.postal_code || (postalInput ? postalInput.value.trim() : '');
    if (zipValue) params.set('zip', zipValue);
    if (item.place_id) params.set('place_id', item.place_id);
    try {
      const res = await fetch(`/api/v1/address/verify?${params.toString()}`, {
        headers: apiHeaders(false),
      });
      if (res.status === 503){
        ADDRESS_AUTOCOMPLETE_DISABLED = true;
        localDisabled = true;
        cleanup();
        return;
      }
      if (!res.ok) return;
      const data = await res.json();
      const candidate = data.candidate || {};
      const changedInputs = new Set();
      if (candidate.delivery_line_1 && setInputValue(line1Input, candidate.delivery_line_1)){
        changedInputs.add(line1Input);
      }
      if (line2Input && candidate.delivery_line_2 && setInputValue(line2Input, candidate.delivery_line_2)){
        changedInputs.add(line2Input);
      }
      if (cityInput && candidate.city && setInputValue(cityInput, candidate.city)){
        changedInputs.add(cityInput);
      }
      if (stateInput && candidate.state && setInputValue(stateInput, candidate.state)){
        changedInputs.add(stateInput);
      }
      if (postalInput && candidate.postal_code && setInputValue(postalInput, candidate.postal_code)){
        changedInputs.add(postalInput);
      }
      const seen = new Set();
      changedInputs.forEach((input) => {
        if (input && !seen.has(input)){
          emitInputEvent(input);
          seen.add(input);
        }
      });
      if (!seen.has(line1Input)) emitInputEvent(line1Input);
    } catch (err) {
      console.warn('Address verification failed', err);
    }
  }

  function onOutsidePointer(ev){
    if (!host.contains(ev.target)) hideSuggestions();
  }

  function onInput(){
    scheduleFetch();
  }

  function onFocus(){
    if (suggestions.length){
      renderSuggestions();
    } else if (line1Input.value.trim().length >= ADDRESS_AUTOCOMPLETE_MIN_CHARS){
      scheduleFetch();
    }
  }

  function onBlur(){
    window.setTimeout(() => {
      if (!host.contains(document.activeElement)) hideSuggestions();
    }, 150);
  }

  function onKeyDown(ev){
    if (!suggestions.length || suggestionBox.style.display === 'none') return;
    if (ev.key === 'ArrowDown'){
      ev.preventDefault();
      const nextIndex = (highlightedIndex + 1) % suggestions.length;
      highlightSuggestion(nextIndex);
    } else if (ev.key === 'ArrowUp'){
      ev.preventDefault();
      const nextIndex = highlightedIndex <= 0 ? suggestions.length - 1 : highlightedIndex - 1;
      highlightSuggestion(nextIndex);
    } else if (ev.key === 'Enter'){
      if (highlightedIndex >= 0 && highlightedIndex < suggestions.length){
        ev.preventDefault();
        applySuggestion(suggestions[highlightedIndex]);
      }
    } else if (ev.key === 'Escape'){
      hideSuggestions();
    }
  }

  function scheduleFetch(){
    if (ADDRESS_AUTOCOMPLETE_DISABLED || localDisabled) return;
    if (debounceTimer) window.clearTimeout(debounceTimer);
    debounceTimer = window.setTimeout(requestSuggestions, ADDRESS_AUTOCOMPLETE_DEBOUNCE);
  }

  async function requestSuggestions(){
    if (ADDRESS_AUTOCOMPLETE_DISABLED || localDisabled) return;
    const query = line1Input.value.trim();
    if (!query || query.length < ADDRESS_AUTOCOMPLETE_MIN_CHARS){
      suggestions = [];
      hideSuggestions();
      return;
    }
    if (query === lastQuery && suggestions.length){
      renderSuggestions();
      return;
    }
    lastQuery = query;
    if (activeController) activeController.abort();
    activeController = new AbortController();
    const params = new URLSearchParams({ query, limit: String(ADDRESS_AUTOCOMPLETE_LIMIT) });
    const cityValue = cityInput ? cityInput.value.trim() : '';
    const stateValue = stateInput ? stateInput.value.trim() : '';
    const zipValue = postalInput ? postalInput.value.trim() : '';
    if (cityValue) params.set('city', cityValue);
    if (stateValue) params.set('state', stateValue);
    if (zipValue) params.set('zip', zipValue);
    try {
      const res = await fetch(`/api/v1/address/suggest?${params.toString()}`, {
        headers: apiHeaders(false),
        signal: activeController.signal,
      });
      if (res.status === 503){
        ADDRESS_AUTOCOMPLETE_DISABLED = true;
        localDisabled = true;
        cleanup();
        return;
      }
      if (!res.ok) throw new Error('Failed to fetch address suggestions');
      const data = await res.json();
      suggestions = Array.isArray(data.suggestions) ? data.suggestions : [];
      if (!suggestions.length){
        hideSuggestions();
      } else {
        renderSuggestions();
      }
    } catch (err) {
      if (err.name === 'AbortError') return;
      console.warn('Address autocomplete failed', err);
      hideSuggestions();
    } finally {
      activeController = null;
    }
  }

  line1Input.addEventListener('input', onInput);
  line1Input.addEventListener('focus', onFocus);
  line1Input.addEventListener('keydown', onKeyDown);
  line1Input.addEventListener('blur', onBlur);
  modal.addEventListener('mousedown', onOutsidePointer);

  return cleanup;
}

function renderTable(data){
  latestTablePayload = data;
  updateRoutePlannerOptions(data);
  const tableData = data.clients || {};
  const head = document.getElementById('clients-head');
  const body = document.getElementById('clients-body');
  head.innerHTML = '';
  body.innerHTML = '';

  const declaredAttributes = Array.isArray(data.attribute_keys) ? data.attribute_keys : [];
  const attributeKeys = new Set(declaredAttributes);
  Object.values(tableData).forEach((entry) => {
    Object.keys(entry || {}).forEach((k) => {
      if (k !== 'name' && !DEMOGRAPHIC_KEYS.has(k)) attributeKeys.add(k);
    });
  });
  const sortedAttributes = Array.from(attributeKeys).sort();
  currentAttributeKeys = sortedAttributes.slice();

  const attributeColumns = sortedAttributes.map((key) => ({
    key,
    label: formatAttributeLabel(key),
    defaultVisible: true
  }));
  const seenKeys = new Set();
  const combinedColumns = [];
  const registerColumn = (col) => {
    if (!col || !col.key || seenKeys.has(col.key)) return;
    seenKeys.add(col.key);
    combinedColumns.push({
      key: col.key,
      label: col.label,
      defaultVisible: col.defaultVisible !== false
    });
  };

  BASE_TABLE_COLUMNS.forEach(registerColumn);
  DEMOGRAPHIC_TABLE_COLUMNS.forEach(registerColumn);
  attributeColumns.forEach(registerColumn);
  availableTableColumns = combinedColumns;
  const columnsToRender = applyColumnPreferences(availableTableColumns);

  const trh = document.createElement('tr');
  columnsToRender.forEach((col) => {
    const th = document.createElement('th');
    th.textContent = col.label;
    trh.appendChild(th);
  });
  const actionsTh = document.createElement('th');
  actionsTh.textContent = 'Actions';
  trh.appendChild(actionsTh);
  head.appendChild(trh);

  Object.keys(tableData).sort((a, b) => a.localeCompare(b)).forEach((clientKey) => {
    const entry = tableData[clientKey] || {};
    const tr = document.createElement('tr');
    tr.classList.add('row');

    columnsToRender.forEach((col) => {
      const td = document.createElement('td');
      td.dataset.label = col.label;
      if (col.key === '__client_key__'){
        td.textContent = clientKey;
        td.classList.add('mono');
      } else if (col.key === 'name'){
        td.textContent = entry.name || '';
        td.style.fontWeight = '600';
      } else {
        td.textContent = formatCellValue(entry[col.key]);
      }
      tr.appendChild(td);
    });

    const tdAct = document.createElement('td');
    tdAct.dataset.label = 'Actions';
    tdAct.className = 'actions-cell';
    const delBtn = document.createElement('button');
    delBtn.className = 'icon-btn';
    delBtn.type = 'button';
    delBtn.title = `Delete ${entry.name || clientKey}`;
    delBtn.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path fill="currentColor" d="M9 3a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1h5v1h-2v16a2 2 0 0 1-2.1 2H8.1A2 2 0 0 1 6 20V4H4V3h5zm1 0h4v1h-4V3zM8 9h2v10H8V9zm4 0h2v10h-2V9zm4 0h2v10h-2V9z"/></svg>`;
    delBtn.addEventListener('click', async (ev) => {
      ev.stopPropagation();
      if (!confirm(`Delete client "${clientKey}"? This cannot be undone.`)) return;
      const r = await safeFetch(`/api/v1/clients/${encodeURIComponent(clientKey)}/delete`, { method: 'POST', headers: apiHeaders(false) });
      if (r.ok) loadTable(); else alert('Delete failed');
    });
    tdAct.appendChild(delBtn);
    tr.appendChild(tdAct);

    tr.addEventListener('click', () => openEditor(clientKey, entry, sortedAttributes));
    body.appendChild(tr);
  });

  renderColumnsOptions();
  Promise.resolve(refreshClientsMap(tableData)).catch((err) => console.warn('Client map refresh failed', err));
}

function loadTable(){
  fetch('/api/v1/clients')
    .then((r) => (r.ok ? r.json() : Promise.reject(r)))
    .then(renderTable)
    .catch(() => alert('Failed to load clients'));
}

function openEditor(clientKey, entry, attributeKeys){
  const modal = document.getElementById('edit-modal');
  const fields = document.getElementById('edit-fields');
  const nameValue = entry.name || '';
  const cleanupCallbacks = [];
  const registerCleanup = (fn) => { if (typeof fn === 'function') cleanupCallbacks.push(fn); };
  const runCleanup = () => {
    while (cleanupCallbacks.length){
      const fn = cleanupCallbacks.pop();
      try { fn(); } catch (err) { console.warn('Cleanup failed', err); }
    }
  };
  const closeModal = () => {
    runCleanup();
    modal.style.display = 'none';
  };
  document.getElementById('edit-title').textContent = `Edit Client: ${clientKey}`;
  fields.innerHTML = '';

  const nameWrap = document.createElement('label');
  nameWrap.style.display = 'block';
  nameWrap.style.marginBottom = '10px';
  nameWrap.textContent = 'Display Name ';
  const nameInput = document.createElement('input');
  nameInput.id = 'edit-name';
  nameInput.value = nameValue;
  nameInput.required = true;
  nameInput.className = 'mono';
  nameWrap.appendChild(nameInput);
  fields.appendChild(nameWrap);

  const demoHeading = document.createElement('h3');
  demoHeading.textContent = 'Demographics';
  demoHeading.style.margin = '12px 0 4px';
  demoHeading.style.fontSize = '1rem';
  demoHeading.style.fontWeight = '600';
  fields.appendChild(demoHeading);

  const demographicsContainer = document.createElement('div');
  demographicsContainer.id = 'demographics-container';
  demographicsContainer.style.display = 'flex';
  demographicsContainer.style.flexDirection = 'column';
  demographicsContainer.style.gap = '8px';
  fields.appendChild(demographicsContainer);

  function addDemographicRow(def){
    const wrap = document.createElement('label');
    wrap.style.display = 'block';
    wrap.style.marginBottom = '6px';
    wrap.textContent = `${def.label} `;
    const input = document.createElement('input');
    input.className = 'mono';
    input.type = def.type || 'text';
    if (def.placeholder) input.placeholder = def.placeholder;
    input.value = entry[def.key] != null ? String(entry[def.key]) : '';
    input.dataset.attrKey = def.key;
    input.dataset.demographic = 'true';
    wrap.appendChild(input);
    const quickLink = attachQuickLink(def, input);
    if (quickLink) wrap.appendChild(quickLink);
    demographicsContainer.appendChild(wrap);
  }

  DEMOGRAPHIC_FIELDS.forEach(addDemographicRow);

  const line1InputEl = demographicsContainer.querySelector('input[data-attr-key="address_line1"]');
  const line2InputEl = demographicsContainer.querySelector('input[data-attr-key="address_line2"]');
  const cityInputEl = demographicsContainer.querySelector('input[data-attr-key="city"]');
  const stateInputEl = demographicsContainer.querySelector('input[data-attr-key="state"]');
  const postalInputEl = demographicsContainer.querySelector('input[data-attr-key="postal_code"]');
  const addressInputs = [
    line1InputEl,
    line2InputEl,
    cityInputEl,
    stateInputEl,
    postalInputEl
  ].filter((input) => !!input);

  function setInputElementValue(input, value){
    if (!input) return false;
    const normalized = value == null ? '' : String(value);
    if (input.value === normalized) return false;
    input.value = normalized;
    return true;
  }

  function emitInputChange(input){
    if (!input) return;
    input.dispatchEvent(new Event('input', { bubbles: true }));
  }

  function applyAddressCandidate(candidate){
    if (!candidate) return;
    const changedInputs = new Set();
    const line1Value = candidate.line1
      || candidate.delivery_line_1
      || candidate.street_line
      || candidate.street
      || candidate.address_line1;
    if (line1Value && setInputElementValue(line1InputEl, line1Value)){
      changedInputs.add(line1InputEl);
    }
    if (line2InputEl){
      const line2Value = candidate.line2
        || candidate.delivery_line_2
        || candidate.secondary
        || candidate.address_line2;
      if (line2Value && setInputElementValue(line2InputEl, line2Value)){
        changedInputs.add(line2InputEl);
      }
    }
    if (cityInputEl && candidate.city && setInputElementValue(cityInputEl, candidate.city)){
      changedInputs.add(cityInputEl);
    }
    const stateValue = candidate.state || candidate.region || candidate.state_province;
    if (stateInputEl && stateValue && setInputElementValue(stateInputEl, stateValue)){
      changedInputs.add(stateInputEl);
    }
    const postalValue = candidate.postal_code || candidate.zip || candidate.postcode;
    if (postalInputEl && postalValue && setInputElementValue(postalInputEl, postalValue)){
      changedInputs.add(postalInputEl);
    }
    const seen = new Set();
    changedInputs.forEach((input) => {
      if (input && !seen.has(input)){
        emitInputChange(input);
        seen.add(input);
      }
    });
    if (line1InputEl && !seen.has(line1InputEl)) emitInputChange(line1InputEl);
  }

  let mapSection = null;
  let mapStatus = null;
  let mapCanvas = null;
  let mapInstance = null;
  let mapMarker = null;
  let mapGeocoder = null;
  let mapApplyButton = null;
  let mapCandidate = null;
  let mapRequestId = 0;

  if (GOOGLE_MAPS_API_KEY){
    mapSection = document.createElement('section');
    mapSection.style.display = 'flex';
    mapSection.style.flexDirection = 'column';
    mapSection.style.gap = '8px';
    mapSection.style.margin = '16px 0';

    const mapHeading = document.createElement('h3');
    mapHeading.textContent = 'Location Preview';
    mapHeading.style.margin = '0';
    mapHeading.style.fontSize = '1rem';
    mapHeading.style.fontWeight = '600';
    mapSection.appendChild(mapHeading);

    mapStatus = document.createElement('p');
    mapStatus.style.margin = '0';
    mapStatus.style.fontSize = '0.875rem';
    mapStatus.style.color = '#555';
    mapStatus.textContent = 'Add an address to preview the pinned map.';
    mapSection.appendChild(mapStatus);

    const mapActions = document.createElement('div');
    mapActions.style.display = 'flex';
    mapActions.style.gap = '8px';
    mapActions.style.alignItems = 'center';
    mapApplyButton = document.createElement('button');
    mapApplyButton.type = 'button';
    mapApplyButton.className = 'btn btn-ghost inline';
    mapApplyButton.textContent = 'Use this address';
    mapApplyButton.disabled = true;
    mapApplyButton.addEventListener('click', () => {
      if (!mapCandidate) return;
      applyAddressCandidate(mapCandidate);
      mapApplyButton.blur();
    });
    mapActions.appendChild(mapApplyButton);
    mapSection.appendChild(mapActions);

    mapCanvas = document.createElement('div');
    mapCanvas.style.width = '100%';
    mapCanvas.style.height = '240px';
    mapCanvas.style.borderRadius = '8px';
    mapCanvas.style.border = '1px solid #e0e0e0';
    mapCanvas.style.backgroundColor = '#f5f5f5';
    mapCanvas.style.overflow = 'hidden';
    mapCanvas.style.display = 'none';
    mapCanvas.setAttribute('role', 'presentation');
    mapSection.appendChild(mapCanvas);

    fields.appendChild(mapSection);
  }

  function collectAddressValues(){
    const values = {};
    addressInputs.forEach((input) => {
      const key = input.dataset.attrKey;
      values[key] = input.value.trim();
    });
    return values;
  }

  function buildAddressString(values){
    if (!values) return '';
    const parts = [];
    if (values.address_line1) parts.push(values.address_line1);
    if (values.address_line2) parts.push(values.address_line2);
    const cityState = [values.city, values.state].filter(Boolean).join(', ');
    if (cityState) parts.push(cityState);
    if (values.postal_code) parts.push(values.postal_code);
    return parts.join(', ');
  }

  function hasMappableAddress(values){
    if (!values) return false;
    const meaningful = [
      values.address_line1,
      values.city,
      values.state,
      values.postal_code
    ].filter((part) => !!part);
    return meaningful.length >= 2;
  }

  function parseGeocodeResult(result){
    if (!result) return null;
    const components = Array.isArray(result.address_components) ? result.address_components : [];
    const findComponent = (types) => {
      const desired = Array.isArray(types) ? types : [types];
      return components.find((component) => {
        const componentTypes = component && Array.isArray(component.types) ? component.types : [];
        return desired.some((type) => componentTypes.includes(type));
      }) || null;
    };
    const getComponentValue = (types, preferShort = false) => {
      const component = findComponent(types);
      if (!component) return '';
      if (preferShort && component.short_name) return component.short_name;
      return component.long_name || component.short_name || '';
    };
    const streetNumber = getComponentValue('street_number');
    const route = getComponentValue('route');
    const streetLine = [streetNumber, route].filter(Boolean).join(' ').trim();
    const secondaryParts = [];
    ['subpremise', 'premise', 'floor', 'unit', 'room'].forEach((type) => {
      const value = getComponentValue(type);
      if (value) secondaryParts.push(value);
    });
    const city = getComponentValue(['locality', 'postal_town', 'sublocality']);
    const state =
      getComponentValue('administrative_area_level_1', true)
      || getComponentValue('administrative_area_level_1');
    const postalCode = getComponentValue('postal_code');
    const country = getComponentValue('country', true) || getComponentValue('country');
    const formatted = result.formatted_address || result.name || '';
    const fallbackLine1 = streetLine || (formatted ? formatted.split(',')[0].trim() : '');
    return {
      line1: fallbackLine1 || null,
      line2: secondaryParts.join(' ').trim() || '',
      city: city || null,
      state: state || null,
      postal_code: postalCode || null,
      country: country || null,
      formatted: formatted || null,
    };
  }

  function updateMapCandidate(candidate){
    mapCandidate = candidate || null;
    if (!mapApplyButton) return;
    if (mapCandidate && mapCandidate.line1){
      mapApplyButton.disabled = false;
      const description = mapCandidate.formatted
        ? `Use ${mapCandidate.formatted}`
        : 'Use the validated address';
      mapApplyButton.title = description;
      mapApplyButton.setAttribute('aria-label', description);
    } else {
      mapApplyButton.disabled = true;
      mapApplyButton.title = 'No validated address available yet';
      mapApplyButton.removeAttribute('aria-label');
    }
  }

  async function refreshClientMap(){
    if (!mapSection || !mapCanvas || !GOOGLE_MAPS_API_KEY){
      return;
    }
    const values = collectAddressValues();
    if (!hasMappableAddress(values)){
      mapStatus.textContent = 'Add an address to preview the pinned map.';
      mapCanvas.style.display = 'none';
      updateMapCandidate(null);
      return;
    }
    const address = buildAddressString(values);
    if (!address){
      mapStatus.textContent = 'Add an address to preview the pinned map.';
      mapCanvas.style.display = 'none';
      updateMapCandidate(null);
      return;
    }
    mapCanvas.style.display = 'block';
    const requestId = ++mapRequestId;
    mapStatus.textContent = 'Locating address…';
    updateMapCandidate(null);
    try {
      const maps = await loadGoogleMaps();
      if (mapRequestId !== requestId) return;
      if (!mapGeocoder){
        mapGeocoder = new maps.Geocoder();
      }
      mapGeocoder.geocode({ address }, (results, status) => {
        if (mapRequestId !== requestId) return;
        if (status === 'OK' && results && results.length){
          const result = results[0];
          const location = result.geometry && result.geometry.location;
          if (!location){
            mapStatus.textContent = 'Google Maps returned an unexpected response.';
            mapCanvas.style.display = 'none';
            updateMapCandidate(null);
            return;
          }
          const formattedAddress = result.formatted_address || address;
          if (!mapInstance){
            mapInstance = new maps.Map(mapCanvas, {
              center: location,
              zoom: 15,
              mapTypeControl: false,
              streetViewControl: false,
              fullscreenControl: false,
            });
          } else {
            mapInstance.setCenter(location);
          }
          if (!mapMarker){
            mapMarker = new maps.Marker({
              map: mapInstance,
              position: location,
              title: formattedAddress,
            });
          } else {
            mapMarker.setMap(mapInstance);
            mapMarker.setPosition(location);
            mapMarker.setTitle(formattedAddress);
          }
          mapStatus.textContent = formattedAddress;
          updateMapCandidate(parseGeocodeResult(result));
        } else if (status === 'ZERO_RESULTS'){
          mapCanvas.style.display = 'none';
          mapStatus.textContent = 'Google Maps could not find this address yet.';
          updateMapCandidate(null);
        } else {
          mapCanvas.style.display = 'none';
          mapStatus.textContent = 'Google Maps returned an error. Please verify the address.';
          updateMapCandidate(null);
        }
      });
    } catch (err) {
      if (mapRequestId !== requestId) return;
      mapCanvas.style.display = 'none';
      mapStatus.textContent = 'Google Maps is unavailable. Check your API key and connectivity.';
      updateMapCandidate(null);
    }
  }

  if (mapSection && addressInputs.length){
    const onAddressInput = () => refreshClientMap();
    addressInputs.forEach((input) => {
      input.addEventListener('input', onAddressInput);
      registerCleanup(() => input.removeEventListener('input', onAddressInput));
    });
    // Trigger initial map render with the existing values.
    setTimeout(() => {
      refreshClientMap();
    }, 0);
    registerCleanup(() => {
      mapRequestId += 1;
      if (mapMarker){
        mapMarker.setMap(null);
      }
      if (mapSection && mapSection.parentElement){
        mapSection.parentElement.removeChild(mapSection);
      }
      mapInstance = null;
      mapMarker = null;
      mapGeocoder = null;
      updateMapCandidate(null);
      mapApplyButton = null;
      mapCandidate = null;
    });
  }

  const autocompleteCleanup = setupAddressAutocomplete({ modal, container: demographicsContainer });
  if (autocompleteCleanup) registerCleanup(autocompleteCleanup);

  const attrHeading = document.createElement('h3');
  attrHeading.textContent = 'Custom Attributes';
  attrHeading.style.margin = '16px 0 4px';
  attrHeading.style.fontSize = '1rem';
  attrHeading.style.fontWeight = '600';
  fields.appendChild(attrHeading);

  const attrContainer = document.createElement('div');
  attrContainer.id = 'attribute-container';
  attrContainer.style.display = 'flex';
  attrContainer.style.flexDirection = 'column';
  attrContainer.style.gap = '8px';
  fields.appendChild(attrContainer);

  const seenAttrKeys = new Set();

  function addAttrRow(key, value){
    if (!key || key === 'name') return;
    const normalizedKey = key;
    if (DEMOGRAPHIC_KEYS.has(normalizedKey)){
      const target = demographicsContainer.querySelector(`input[data-attr-key="${normalizedKey}"]`);
      if (target){
        target.value = value == null ? '' : String(value);
        target.dispatchEvent(new Event('input'));
      }
      return;
    }
    if (seenAttrKeys.has(normalizedKey)){
      const existing = attrContainer.querySelector(`input[data-attr-key="${normalizedKey}"]`);
      if (existing){
        existing.value = value == null ? '' : String(value);
      }
      return;
    }
    seenAttrKeys.add(normalizedKey);
    const wrap = document.createElement('label');
    wrap.style.display = 'block';
    wrap.style.marginBottom = '6px';
    wrap.textContent = normalizedKey.replace(/_/g, ' ') + ' ';
    const input = document.createElement('input');
    input.value = value == null ? '' : String(value);
    input.dataset.attrKey = normalizedKey;
    input.className = 'mono';
    wrap.appendChild(input);
    attrContainer.appendChild(wrap);
  }

  if (Array.isArray(attributeKeys) && attributeKeys.length){
    attributeKeys.forEach((key) => addAttrRow(key, entry[key]));
  }
  Object.keys(entry || {}).forEach((key) => {
    if (key === 'name') return;
    addAttrRow(key, entry[key]);
  });

  document.getElementById('edit-close').onclick = closeModal;
  modal.style.display = 'block';

  document.getElementById('edit-form').onsubmit = async (ev) => {
    ev.preventDefault();
    const name = nameInput.value.trim();
    if (!name){
      alert('Display name is required');
      return;
    }
    const payload = { name, attributes: {} };
    demographicsContainer.querySelectorAll('input[data-attr-key]').forEach((inp) => {
      const key = inp.dataset.attrKey;
      if (!key) return;
      payload.attributes[key] = inp.value.trim();
    });
    attrContainer.querySelectorAll('input[data-attr-key]').forEach((inp) => {
      const key = inp.dataset.attrKey;
      if (!key) return;
      payload.attributes[key] = inp.value.trim();
    });
    const r = await safeFetch(`/api/v1/clients/${encodeURIComponent(clientKey)}`, {
      method: 'PATCH',
      headers: apiHeaders(true),
      body: JSON.stringify(payload)
    });
    if (r.ok){
      closeModal();
      loadTable();
    } else {
      alert('Save failed');
    }
  };

}

const attributesModal = document.getElementById('attributes-modal');
const attributesList = document.getElementById('attributes-list');
const manageAttributesBtn = document.getElementById('manage-attributes');
const attributesCloseBtn = document.getElementById('attributes-close');
const attributeAddForm = document.getElementById('attribute-add-form');
const attributeNewKeyInput = document.getElementById('attribute-new-key');
const columnsModal = document.getElementById('columns-modal');
const columnsCloseBtn = document.getElementById('columns-close');
const customizeColumnsBtn = document.getElementById('customize-columns');
const columnsForm = document.getElementById('columns-form');
const columnsOptions = document.getElementById('columns-options');

function closeAttributesModal(){
  if (attributesModal) attributesModal.style.display = 'none';
}

function closeColumnsModal(){
  if (columnsModal) columnsModal.style.display = 'none';
}

function renderColumnsOptions(){
  if (!columnsOptions) return;
  columnsOptions.innerHTML = '';
  if (!availableTableColumns.length){
    const empty = document.createElement('p');
    empty.textContent = 'No columns available yet.';
    empty.style.margin = '8px 0';
    columnsOptions.appendChild(empty);
    return;
  }
  availableTableColumns.forEach((col) => {
    const checkboxId = `column-option-${col.key.replace(/[^a-zA-Z0-9_-]/g, '-')}`;
    const label = document.createElement('label');
    label.className = 'column-option';
    label.htmlFor = checkboxId;
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = checkboxId;
    checkbox.value = col.key;
    checkbox.checked = visibleColumnKeys.has(col.key);
    const span = document.createElement('span');
    span.textContent = col.label;
    label.appendChild(checkbox);
    label.appendChild(span);
    columnsOptions.appendChild(label);
  });
}

function normalizeRouteField(value){
  if (value == null) return '';
  if (typeof value === 'string') return value.trim();
  return String(value).trim();
}

function buildRoutePlannerAddress(entry){
  if (!entry || typeof entry !== 'object') return null;
  const line1 = normalizeRouteField(entry.address_line1);
  const line2 = normalizeRouteField(entry.address_line2);
  const city = normalizeRouteField(entry.city);
  const state = normalizeRouteField(entry.state);
  const postal = normalizeRouteField(entry.postal_code);
  const country = normalizeRouteField(entry.country);
  if (!line1 || !(city || state || postal)) return null;
  const parts = [line1];
  if (line2) parts.push(line2);
  const cityState = [city, state].filter(Boolean).join(', ');
  if (cityState) parts.push(cityState);
  if (postal) parts.push(postal);
  if (country && !/^us(a)?$/i.test(country)) parts.push(country);
  return parts.join(', ');
}

function cancelPendingRoute(){
  routeRequestId += 1;
}

function resetRouteVisualization(){
  if (routeDirectionsRenderer){
    routeDirectionsRenderer.set('directions', null);
  }
  if (routeSummary){
    routeSummary.innerHTML = '';
  }
  if (routeMapCanvas && !routeSelection.length){
    routeMapCanvas.style.display = 'none';
  }
}

function updateRoutePlannerOptions(data){
  if (!routeClientSelect) return;
  const previousLength = routeSelection.length;
  routeSelectableClients.clear();
  routeClientSelect.innerHTML = '';
  const clients = (data && data.clients) || {};
  const options = [];
  Object.entries(clients).forEach(([clientKey, entry]) => {
    const address = buildRoutePlannerAddress(entry);
    if (!address) return;
    const name = normalizeRouteField(entry.name) || clientKey;
    routeSelectableClients.set(clientKey, { clientKey, name, address });
    options.push({ clientKey, name, address });
  });
  ROUTE_PLANNER_STATIC_STOPS.forEach((stop) => {
    if (!stop || !stop.clientKey || !stop.name || !stop.address) return;
    routeSelectableClients.set(stop.clientKey, {
      clientKey: stop.clientKey,
      name: stop.name,
      address: stop.address
    });
    options.push({ clientKey: stop.clientKey, name: stop.name, address: stop.address });
  });
  options.sort((a, b) => a.name.localeCompare(b.name));
  options.forEach((opt) => {
    const option = document.createElement('option');
    option.value = opt.clientKey;
    option.textContent = `${opt.name} — ${opt.address}`;
    routeClientSelect.appendChild(option);
  });
  routeSelection = routeSelection.filter((stop) => routeSelectableClients.has(stop.clientKey));
  if (routeSelection.length !== previousLength){
    cancelPendingRoute();
    resetRouteVisualization();
  }
  if (routeStatus){
    if (!GOOGLE_MAPS_API_KEY){
      routeStatus.textContent = 'Set the GOOGLE_MAPS_API_KEY environment variable to enable the route planner.';
    } else if (!options.length){
      routeStatus.textContent = 'Add client addresses to populate the route planner with customer stops.';
    } else if (!routeSelection.length){
      routeStatus.textContent = 'Select stops and add them to the route.';
    }
  }
  renderRouteSelection();
}

function createRouteStopElement(stop, index, total){
  const row = document.createElement('div');
  row.className = 'route-stop';
  const order = document.createElement('span');
  order.className = 'route-stop__index';
  order.textContent = String(index + 1);
  row.appendChild(order);

  const meta = document.createElement('div');
  meta.className = 'route-stop__meta';
  const nameEl = document.createElement('span');
  nameEl.className = 'route-stop__name';
  nameEl.textContent = stop.name;
  const addressEl = document.createElement('span');
  addressEl.className = 'route-stop__address';
  addressEl.textContent = stop.address;
  meta.appendChild(nameEl);
  meta.appendChild(addressEl);
  row.appendChild(meta);

  const controls = document.createElement('div');
  controls.className = 'route-stop__controls';

  const upBtn = document.createElement('button');
  upBtn.type = 'button';
  upBtn.className = 'route-stop__btn';
  upBtn.textContent = '↑';
  upBtn.setAttribute('aria-label', `Move ${stop.name} up`);
  upBtn.dataset.action = 'up';
  upBtn.dataset.index = String(index);
  if (index === 0) upBtn.disabled = true;
  controls.appendChild(upBtn);

  const downBtn = document.createElement('button');
  downBtn.type = 'button';
  downBtn.className = 'route-stop__btn';
  downBtn.textContent = '↓';
  downBtn.setAttribute('aria-label', `Move ${stop.name} down`);
  downBtn.dataset.action = 'down';
  downBtn.dataset.index = String(index);
  if (index === total - 1) downBtn.disabled = true;
  controls.appendChild(downBtn);

  const removeBtn = document.createElement('button');
  removeBtn.type = 'button';
  removeBtn.className = 'route-stop__btn route-stop__btn--remove';
  removeBtn.textContent = '×';
  removeBtn.setAttribute('aria-label', `Remove ${stop.name} from the route`);
  removeBtn.dataset.action = 'remove';
  removeBtn.dataset.index = String(index);
  controls.appendChild(removeBtn);

  row.appendChild(controls);
  return row;
}

function renderRouteSelection(){
  if (!routeSelectionList) return;
  routeSelectionList.innerHTML = '';
  if (!routeSelection.length){
    const empty = document.createElement('p');
    empty.className = 'route-planner__empty';
    empty.textContent = 'No stops added yet. Select stops and click “Add to Route.”';
    routeSelectionList.appendChild(empty);
  } else {
    routeSelection.forEach((stop, index) => {
      routeSelectionList.appendChild(createRouteStopElement(stop, index, routeSelection.length));
    });
  }
  if (routeBuildButton) routeBuildButton.disabled = !routeSelection.length;
  if (routeOptimizeButton) routeOptimizeButton.disabled = routeSelection.length < 2;
  if (routeClearButton) routeClearButton.disabled = !routeSelection.length;
}

async function ensureRouteMap(){
  if (!GOOGLE_MAPS_API_KEY || !routeMapCanvas) return null;
  const maps = await loadGoogleMaps();
  if (!routeMapInstance){
    routeMapInstance = new maps.Map(routeMapCanvas, {
      center: ROUTE_PLANNER_ORIGIN_COORDS,
      zoom: 11,
      mapTypeControl: false,
      streetViewControl: false,
      fullscreenControl: false,
    });
  }
  if (!routeDirectionsService){
    routeDirectionsService = new maps.DirectionsService();
  }
  if (!routeDirectionsRenderer){
    routeDirectionsRenderer = new maps.DirectionsRenderer({
      map: routeMapInstance,
      suppressMarkers: false,
      polylineOptions: { strokeColor: '#0091EA', strokeWeight: 5 },
    });
  } else if (routeDirectionsRenderer.getMap() !== routeMapInstance){
    routeDirectionsRenderer.setMap(routeMapInstance);
  }
  routeMapCanvas.style.display = 'block';
  return maps;
}

function formatDistance(meters){
  if (typeof meters !== 'number' || !Number.isFinite(meters) || meters <= 0) return '';
  const miles = meters / 1609.344;
  if (miles >= 10) return `${Math.round(miles)} mi`;
  if (miles >= 1) return `${miles.toFixed(1)} mi`;
  const yards = meters * 1.09361;
  if (yards >= 100) return `${Math.round(yards)} yd`;
  return `${Math.round(meters)} m`;
}

function formatDuration(seconds){
  if (typeof seconds !== 'number' || !Number.isFinite(seconds) || seconds <= 0) return '';
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.round((seconds % 3600) / 60);
  if (hours && minutes){
    return `${hours}h ${minutes}m`;
  }
  if (hours){
    return `${hours}h`;
  }
  return `${minutes || 1}m`;
}

function renderRouteSummary(result){
  if (!routeSummary) return;
  const route = result && result.routes && result.routes[0];
  const legs = route && Array.isArray(route.legs) ? route.legs : [];
  if (!legs.length){
    routeSummary.innerHTML = '';
    return;
  }
  let totalDistance = 0;
  let totalDuration = 0;
  const list = document.createElement('ol');
  list.className = 'route-summary__legs';
  legs.forEach((leg, index) => {
    const item = document.createElement('li');
    item.className = 'route-summary__leg';
    const heading = document.createElement('div');
    heading.className = 'route-summary__leg-heading';
    const start = leg.start_address || `Stop ${index}`;
    const end = leg.end_address || `Stop ${index + 1}`;
    heading.textContent = `${start} → ${end}`;
    const meta = document.createElement('div');
    meta.className = 'route-summary__leg-meta';
    const legDistance = leg.distance && leg.distance.value;
    const legDuration = leg.duration && leg.duration.value;
    if (typeof legDistance === 'number'){ totalDistance += legDistance; }
    if (typeof legDuration === 'number'){ totalDuration += legDuration; }
    const distanceText = leg.distance && leg.distance.text ? leg.distance.text : formatDistance(legDistance);
    const durationText = leg.duration && leg.duration.text ? leg.duration.text : formatDuration(legDuration);
    meta.textContent = `${distanceText || '—'} • ${durationText || '—'}`;
    item.appendChild(heading);
    item.appendChild(meta);
    list.appendChild(item);
  });

  const totals = document.createElement('div');
  totals.className = 'route-summary__totals';
  const totalDistanceText = formatDistance(totalDistance) || '—';
  const totalDurationText = formatDuration(totalDuration) || '—';
  totals.innerHTML = `<span>Total distance: <strong>${totalDistanceText}</strong></span><span>Total drive time: <strong>${totalDurationText}</strong></span>`;

  routeSummary.innerHTML = '';
  routeSummary.appendChild(totals);
  routeSummary.appendChild(list);
}

function applyOptimizedOrder(route){
  if (!routeSelection.length) return;
  const waypointOrder = Array.isArray(route.waypoint_order) ? route.waypoint_order : [];
  if (!waypointOrder.length) return;
  const stops = routeSelection.slice(0, -1);
  const finalStop = routeSelection[routeSelection.length - 1];
  if (!stops.length) return;
  const optimizedStops = waypointOrder.map((index) => stops[index]).filter(Boolean);
  routeSelection = optimizedStops.concat(finalStop ? [finalStop] : []);
  renderRouteSelection();
}

async function requestRoute(optimize){
  if (!routeSelection.length){
    if (routeStatus) routeStatus.textContent = 'Add at least one stop to build a route.';
    return;
  }
  if (!GOOGLE_MAPS_API_KEY){
    if (routeStatus) routeStatus.textContent = 'Set the GOOGLE_MAPS_API_KEY environment variable to calculate routes.';
    return;
  }
  try {
    const maps = await ensureRouteMap();
    if (!maps || !routeDirectionsService){
      throw new Error('Google Maps unavailable');
    }
    const stops = routeSelection.map((stop) => stop.address);
    const origin = ROUTE_PLANNER_ORIGIN;
    const destination = stops[stops.length - 1] || origin;
    const waypoints = stops.slice(0, -1).map((address) => ({ location: address, stopover: true }));
    const request = {
      origin,
      destination,
      travelMode: maps.TravelMode.DRIVING,
    };
    if (waypoints.length){
      request.waypoints = waypoints;
      if (optimize) request.optimizeWaypoints = true;
    }
    if (routeStatus){
      routeStatus.textContent = optimize ? 'Requesting optimized route…' : 'Building route…';
    }
    const requestId = ++routeRequestId;
    routeDirectionsService.route(request, (result, status) => {
      if (routeRequestId !== requestId) return;
      if (status === 'OK' && result){
        routeDirectionsRenderer.setDirections(result);
        renderRouteSummary(result);
        if (optimize && result.routes && result.routes.length){
          applyOptimizedOrder(result.routes[0]);
          if (routeStatus) routeStatus.textContent = 'Optimized route ready. Adjust manually if needed.';
        } else if (routeStatus){
          routeStatus.textContent = 'Route ready.';
        }
        if (routeMapCanvas) routeMapCanvas.style.display = 'block';
      } else {
        resetRouteVisualization();
        if (routeStatus) routeStatus.textContent = 'Google Maps could not compute a route for the selected stops.';
      }
    });
  } catch (err) {
    console.warn('Route planner failed', err);
    resetRouteVisualization();
    if (routeStatus) routeStatus.textContent = 'Route planner is unavailable. Check your Google Maps configuration.';
  }
}

if (routeAddButton && routeClientSelect){
  routeAddButton.addEventListener('click', () => {
    const selectedOptions = Array.from(routeClientSelect.selectedOptions || []);
    if (!selectedOptions.length){
      if (routeStatus) routeStatus.textContent = 'Select stops in the list before adding them to the route.';
      return;
    }
    let added = 0;
    selectedOptions.forEach((option) => {
      const clientKey = option.value;
      if (!clientKey || !routeSelectableClients.has(clientKey)) return;
      if (routeSelection.some((stop) => stop.clientKey === clientKey)) return;
      const base = routeSelectableClients.get(clientKey);
      if (!base) return;
      routeSelection.push({ clientKey: base.clientKey, name: base.name, address: base.address });
      added += 1;
    });
    if (added){
      cancelPendingRoute();
      resetRouteVisualization();
      renderRouteSelection();
      if (routeStatus) routeStatus.textContent = `Added ${added} stop${added === 1 ? '' : 's'} to the route.`;
    } else if (routeStatus){
      routeStatus.textContent = 'All selected stops are already in the route.';
    }
  });
}

if (routeClearButton){
  routeClearButton.addEventListener('click', () => {
    if (!routeSelection.length) return;
    routeSelection = [];
    cancelPendingRoute();
    resetRouteVisualization();
    renderRouteSelection();
    if (routeStatus) routeStatus.textContent = 'Route cleared.';
  });
}

if (routeSelectionList){
  routeSelectionList.addEventListener('click', (event) => {
    const button = event.target.closest('button[data-action]');
    if (!button) return;
    const index = Number(button.dataset.index);
    if (!Number.isInteger(index) || index < 0 || index >= routeSelection.length) return;
    const action = button.dataset.action;
    if (action === 'remove'){
      routeSelection.splice(index, 1);
      cancelPendingRoute();
      resetRouteVisualization();
      renderRouteSelection();
      if (routeStatus) routeStatus.textContent = 'Stop removed from the route.';
    } else if (action === 'up' && index > 0){
      const [stop] = routeSelection.splice(index, 1);
      routeSelection.splice(index - 1, 0, stop);
      cancelPendingRoute();
      resetRouteVisualization();
      renderRouteSelection();
      if (routeStatus) routeStatus.textContent = 'Stop order updated. Rebuild the route to view changes.';
    } else if (action === 'down' && index < routeSelection.length - 1){
      const [stop] = routeSelection.splice(index, 1);
      routeSelection.splice(index + 1, 0, stop);
      cancelPendingRoute();
      resetRouteVisualization();
      renderRouteSelection();
      if (routeStatus) routeStatus.textContent = 'Stop order updated. Rebuild the route to view changes.';
    }
  });
}

if (routeBuildButton){
  routeBuildButton.addEventListener('click', () => {
    requestRoute(false);
  });
}

if (routeOptimizeButton){
  routeOptimizeButton.addEventListener('click', () => {
    requestRoute(true);
  });
}

function renderAttributesManager(){
  if (!attributesList) return;
  attributesList.innerHTML = '';
  if (!currentAttributeKeys.length){
    const empty = document.createElement('p');
    empty.textContent = 'No custom attributes yet.';
    empty.style.margin = '8px 0';
    attributesList.appendChild(empty);
    return;
  }
  currentAttributeKeys.forEach((key) => {
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.justifyContent = 'space-between';
    row.style.gap = '8px';
    row.style.marginBottom = '6px';

    const label = document.createElement('span');
    label.textContent = key;
    label.className = 'mono';
    label.style.flex = '1';
    row.appendChild(label);

    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'btn';
    removeBtn.textContent = 'Remove';
    removeBtn.addEventListener('click', async () => {
      if (!confirm(`Remove attribute "${key}"? This will delete the value for all clients.`)) return;
      try {
        const res = await safeFetch(`/api/v1/clients/attributes/${encodeURIComponent(key)}`, {
          method: 'DELETE',
          headers: apiHeaders(false)
        });
        if (!res.ok){
          throw new Error('Failed to remove attribute');
        }
        const data = await res.json();
        currentAttributeKeys = Array.isArray(data.attribute_keys) ? data.attribute_keys.slice().sort((a, b) => a.localeCompare(b)) : currentAttributeKeys.filter((k) => k !== key);
        renderAttributesManager();
        loadTable();
      } catch (err) {
        console.error(err);
        alert('Failed to remove attribute');
      }
    });
    row.appendChild(removeBtn);
    attributesList.appendChild(row);
  });
}

async function refreshAttributeKeysFromServer(){
  const res = await safeFetch('/api/v1/clients/attributes');
  if (!res.ok){
    throw new Error('Failed to load custom attributes');
  }
  const data = await res.json();
  currentAttributeKeys = Array.isArray(data.attribute_keys) ? data.attribute_keys.slice().sort((a, b) => a.localeCompare(b)) : [];
  return currentAttributeKeys;
}

if (attributesCloseBtn){
  attributesCloseBtn.addEventListener('click', closeAttributesModal);
}

if (columnsCloseBtn){
  columnsCloseBtn.addEventListener('click', closeColumnsModal);
}

if (customizeColumnsBtn){
  customizeColumnsBtn.addEventListener('click', () => {
    renderColumnsOptions();
    if (columnsModal) columnsModal.style.display = 'block';
  });
}

if (columnsForm){
  columnsForm.addEventListener('submit', (ev) => {
    ev.preventDefault();
    if (!columnsOptions) return;
    const selected = Array.from(columnsOptions.querySelectorAll('input[type="checkbox"]'))
      .filter((input) => input.checked)
      .map((input) => input.value);
    if (!selected.length){
      alert('Select at least one column to display');
      return;
    }
    visibleColumnKeys = new Set(selected);
    saveColumnPreferences(selected, availableTableColumns.map((col) => col.key));
    closeColumnsModal();
    if (latestTablePayload) renderTable(latestTablePayload);
  });
}

if (manageAttributesBtn){
  manageAttributesBtn.addEventListener('click', async () => {
    try {
      await refreshAttributeKeysFromServer();
      renderAttributesManager();
      if (attributesModal) attributesModal.style.display = 'block';
    } catch (err) {
      console.error(err);
      alert('Failed to load custom attributes');
    }
  });
}

if (attributeAddForm){
  attributeAddForm.addEventListener('submit', async (ev) => {
    ev.preventDefault();
    const key = attributeNewKeyInput ? (attributeNewKeyInput.value || '').trim() : '';
    if (!key) return;
    try {
      const res = await safeFetch('/api/v1/clients/attributes', {
        method: 'POST',
        headers: apiHeaders(true),
        body: JSON.stringify({ key })
      });
      if (res.ok){
        const data = await res.json();
        currentAttributeKeys = Array.isArray(data.attribute_keys) ? data.attribute_keys.slice().sort((a, b) => a.localeCompare(b)) : currentAttributeKeys;
        if (attributeNewKeyInput) attributeNewKeyInput.value = '';
        renderAttributesManager();
        loadTable();
      } else if (res.status === 409){
        alert('Attribute already exists');
      } else if (res.status === 422){
        const data = await res.json().catch(() => ({}));
        alert(data.detail || 'Attribute key is invalid');
      } else {
        throw new Error('Failed to add attribute');
      }
    } catch (err) {
      console.error(err);
      alert('Failed to add attribute');
    }
  });
}

document.getElementById('create-client').addEventListener('click', async () => {
  const clientKey = prompt('New client key (e.g., nds):');
  if (!clientKey) return;
  const name = prompt('Display name for this client:');
  if (!name) return;
  const r = await safeFetch('/api/v1/clients', {
    method: 'POST',
    headers: apiHeaders(true),
    body: JSON.stringify({ client_key: clientKey.trim(), name: name.trim(), attributes: {} })
  });
  if (r.ok) loadTable(); else alert('Create failed');
});

loadTable();
</script>

